/* 
 * Copyright 2018 University of Toronto
 *
 * Permission is hereby granted, to use this software and associated 
 * documentation files (the "Software") in course work at the University 
 * of Toronto, or for personal use. Other uses are prohibited, in 
 * particular the distribution of the Software either publicly or to third 
 * parties.
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "m1.h"
#include <cmath>
#include <algorithm>
#include "StreetsDatabaseAPI.h"

bool load_map(std::string map_path) {
    bool load_successful = false; //Indicates whether the map has loaded 
                                  //successfully

    loadStreetsDatabaseBIN(map_path);
    //
    //Load your map related data structures here
    //

    

    load_successful = true; //Make sure this is updated to reflect whether
                            //loading the map succeeded or failed

    return load_successful;
}

void close_map() {
    //Clean-up your map related data structures here
    void closeStreetDatabase(); 
}


//Returns street id(s) for the given street name
//If no street with this name exists, returns a 0-length vector.
std::vector<unsigned> find_street_ids_from_name(std::string street_name){
    //make vector
    /*std::vector<unsigned> matching_street_ids; 

    //loop through street ids
    for(unsigned i = 0; i < getNumberOfStreets(); i++){
        //if name matches add id to vector
        if(getStreetName(i) == street_name){
            matching_street_ids.push_back(i);
        }
    }
    //return vector
    return matching_street_ids;*/   
}

//Returns the street segments for the given intersection 
std::vector<unsigned> find_intersection_street_segments(unsigned intersection_id){
    //make vector to store segments
    std::vector<unsigned> street_segments;
    
    //loop through street segments, adding them too vector
    for(unsigned i = 0;i < getIntersectionStreetSegmentCount(intersection_id); i++){
        //add street segment to vector
        street_segments.push_back(getIntersectionStreetSegment(intersection_id, i));
    }
    return street_segments;
}

//Returns the street names at the given intersection (includes duplicate street 
//names in returned vector)
std::vector<std::string> find_intersection_street_names(unsigned intersection_id){
    
    std::vector<std::string> street_names;
    
    //loop through street segment
    for(unsigned i = 0; i < getIntersectionStreetSegmentCount(intersection_id); i++){
        
        //add name of street from each segment
        street_names.push_back(getStreetName(getStreetSegmentInfo(getIntersectionStreetSegment(intersection_id, i)).streetID));
    }
    
    
}

//Returns true if you can get from intersection1 to intersection2 using a single 
//street segment (hint: check for 1-way streets too)
//corner case: an intersection is considered to be connected to itself
bool are_directly_connected(unsigned intersection_id1, unsigned intersection_id2){
    
    //corner case
    if(intersection_id1 == intersection_id2) return true;
    
    //check each street seg connected to intersection 1
    for(int i = 0; i < getIntersectionStreetSegmentCount(intersection_id1); i++){
        
        //check if "to" value is intersection2 -> directly connected if so
        if((getStreetSegmentInfo(getIntersectionStreetSegment(intersection_id1, i)).to) == intersection_id2){
            return true;
        }
    }
    return false;
    
}

//Returns all intersections reachable by traveling down one street segment 
//from given intersection (hint: you can't travel the wrong way on a 1-way street)
//the returned vector should NOT contain duplicate intersections
std::vector<unsigned> find_adjacent_intersections(unsigned intersection_id){
    std::vector<unsigned> intersections;
    
    //loop through all segments connected to intersection
    for(unsigned i = 0; i < getIntersectionStreetSegmentCount(intersection_id); i++){
        
        //if not already in vector intersections
        if(std::find(intersections.begin(), intersections.end(), getStreetSegmentInfo(getIntersectionStreetSegment(intersection_id, i)).to) == intersections.end()){
            //add "to" intersection to vector
            intersections.push_back(getStreetSegmentInfo(getIntersectionStreetSegment(intersection_id, i)).to);
        }
    }
    return intersections;
    
}

//Returns all street segments for the given street
std::vector<unsigned> find_street_street_segments(unsigned street_id){
    
    std::vector<unsigned> all_street_segments;
    
    for(int i = 0; i < getNumberOfStreetSegments(); i++){
        if(getStreetSegmentInfo(i).streetID == street_id){
            all_street_segments.push_back(i);
        }
    }
    
    return all_street_segments;
}

//Returns all intersections along the a given street
std::vector<unsigned> find_all_street_intersections(unsigned street_id){

    std::vector<unsigned> all_street_intersections;
    
    for(int i = 0; i < getNumberOfIntersections(); i++){
        
        //If the current street segment is on the street of interest
        if(getStreetSegmentInfo(i).streetID == street_id){
            
            IntersectionIndex from, to;
            from = getStreetSegmentInfo(i).from;
            to = getStreetSegmentInfo(i).to;
            bool unique_from = true;
            bool unique_to = true;
            
            //Check if the intersection was already added to the vector
            for(int j = 0; j < all_street_intersections.size(); j++){
                
                if(all_street_intersections[j] == from){
                    unique_from = false;
                }
                else if(all_street_intersections[j] == to){
                    unique_to = false;
                }
            }
            if(unique_from)
                all_street_intersections.push_back(from);
            if(unique_to)
                all_street_intersections.push_back(to);
        }
    }
    
    return all_street_intersections;
}

//Return all intersection ids for two intersecting streets
//This function will typically return one intersection id.
//However street names are not guarenteed to be unique, so more than 1 intersection id
//may exist
std::vector<unsigned> find_intersection_ids_from_street_names(std::string street_name1, 
                                                              std::string street_name2){
    std::vector<unsigned> all_street_intersection_ids;
    
    // Find all streets with the given name
    std::vector<unsigned> street_1_ids = find_street_ids_from_name(street_name1);
    std::vector<unsigned> street_2_ids = find_street_ids_from_name(street_name2);

    // TODO: loop over all street combinations

    //Find all street intersections for street 1 and 2
    //std::vector<unsigned> street_1_intersections = find_all_street_intersections(find_street_ids_from_name(street_name1));
    //std::vector<unsigned> street_2_intersections = find_all_street_intersections(find_street_ids_from_name(street_name2));

    if (street_1_ids.size() == 0 || street_2_ids.size() == 0)
	return all_street_intersection_ids;

    std::vector<unsigned> street_1_intersections = find_all_street_intersections(street_1_ids[0]);
    std::vector<unsigned> street_2_intersections = find_all_street_intersections(street_2_ids[0]);
	
    //Compare intersections for streets 1 and 2 to see which match up 
    for(int i = 0; i < street_1_intersections.size(); i++){
        for(int j = 0; j < street_2_intersections.size(); j++){
            if(street_1_intersections[i] == street_2_intersections[j]){
                all_street_intersection_ids.push_back(street_1_intersections[i]);
            }
        }
    }
    return all_street_intersection_ids;
}

//Returns the distance between two coordinates in meters
double find_distance_between_two_points(LatLon point1, LatLon point2) {
    //Basically just put down the formula from handout
    double distance_between_2_points;
    double x1, x2, y1, y2, x, y;
    y1 = point1.lat() * DEG_TO_RAD;
    y2 = point2.lat() * DEG_TO_RAD;
    double latavg = ((y1 + y2) / 2);
    x1 = point1.lon() * DEG_TO_RAD * std::cos(latavg);
    x2 = point2.lon() * DEG_TO_RAD * std::cos(latavg);
    x = (x2 - x1);
    y = (y2 - y1);
    distance_between_2_points = std::abs(EARTH_RADIUS_IN_METERS * std::sqrt(std::pow(y, 2) + std::pow(x, 2)));
    //std::cout << distance_between_2_points << "\n";
    return distance_between_2_points;
}

//Returns the length of the given street segment in meters
double find_street_segment_length(unsigned street_segment_id) {
    //Basically if no curve points, just use find_distance_between_two_points. If there is, iterate and sum up individual mini street segments.
    double length = 0;
    unsigned curve_points = getStreetSegmentInfo(street_segment_id).curvePointCount;
    LatLon point1 = getIntersectionPosition(getStreetSegmentInfo(street_segment_id).from);
    LatLon point2 = getIntersectionPosition(getStreetSegmentInfo(street_segment_id).to);
    if (curve_points == 0) {
        length = find_distance_between_two_points(point1, point2);
    } else if (curve_points == 1) {
        length = length + find_distance_between_two_points(point1, getStreetSegmentCurvePoint(street_segment_id, 0));
        length = length + find_distance_between_two_points(getStreetSegmentCurvePoint(street_segment_id, curve_points- 1), point2);
    } else {
        for (int i = 0; i < curve_points -1; i++) {
            length = length + find_distance_between_two_points(getStreetSegmentCurvePoint(street_segment_id, i), getStreetSegmentCurvePoint(street_segment_id, i + 1));
        }
        length = length + find_distance_between_two_points(point1, getStreetSegmentCurvePoint(street_segment_id, 0));
                length = length + find_distance_between_two_points(getStreetSegmentCurvePoint(street_segment_id, curve_points- 1), point2);
    }

    return (length);
}

//Returns the length of the specified street in meters
double find_street_length(unsigned street_id) {
    //Using the find streets using street ID store in vector then compute each segment's length.
    double street_length = 0;
    std::vector<unsigned> segments_of_street = find_street_street_segments(street_id);
    for (unsigned i = 0; i < segments_of_street.size(); i++) {
        street_length = street_length + find_street_segment_length(segments_of_street[i]);
    }
    return (street_length);
}

//Returns the travel time to drive a street segment in seconds 
//(time = distance/speed_limit)
double find_street_segment_travel_time(unsigned street_segment_id) {
    double travel_time = ((find_street_segment_length(street_segment_id)/1000)/getStreetSegmentInfo(street_segment_id).speedLimit)*60*60 ;
    return (travel_time);
}

//Returns the nearest point of interest to the given position
unsigned find_closest_point_of_interest(LatLon my_position) {
    
    unsigned number_of_points = getNumberOfPointsOfInterest();
    unsigned closest_point = 0;
    double closest_distance = find_distance_between_two_points(my_position, getPointOfInterestPosition(0));
    // loops through the whole list and compares the values to find the closest location
    for (unsigned i = 1; i < number_of_points; i++) {
        double current_distance = find_distance_between_two_points(my_position, 
                getPointOfInterestPosition(i)); // finds the distance to the point currently analysing
        // if the current location is closer then stores the values
        if (current_distance < closest_distance) {
            closest_distance = current_distance;
            closest_point = i;
        }
    }
    return closest_point; // returns the index of the closest point of interest

}

//Returns the the nearest intersection to the given position
unsigned find_closest_intersection(LatLon my_position) {
    
    unsigned number_of_intersections = getNumberOfIntersections();
    unsigned closest_intersection = 0;
    double closest_distance = find_distance_between_two_points(my_position, getIntersectionPosition(0));
    // loops through the whole list and compares the values to find the closest location
    for (unsigned i = 1; i < number_of_intersections; i++) {
        double current_distance = find_distance_between_two_points(my_position,
                getIntersectionPosition(i)); // finds the distance to the point currently analysing
        // if the current location is closer then stores the values
        if (current_distance < closest_distance) {
            closest_distance = current_distance;
            closest_intersection = i;        
        }
    }
    return closest_intersection; // returns the index of the closest intersection

    
}
